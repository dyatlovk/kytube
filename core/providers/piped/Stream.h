#pragma once

#include <iostream>
#include <string>
#include <sys/types.h>
#include <vector>

#include <json/single_include/nlohmann/json.hpp>

#include "PipedException.h"

namespace piped
{
  class stream
  {
  public:
    struct Response;
    struct AudioStream;
    struct VideoStream;
    struct RelatedStream;
    struct Stream; // audio and video
    struct Subtitle;
    struct PreviewFrame;

  public:
    stream() = default;
    ~stream() { delete response.dash; }

    auto GetParsedData() -> const Response *;

    auto Parse(const std::string &buffer) -> void
    {
      json j;
      try
      {
        j = json::parse(buffer);
      }
      catch (json::parse_error &ex)
      {
        std::cout << "parse error at byte " << ex.byte << std::endl;
        return;
      }

      response.title = j["title"].get<std::string>();
      response.description = j["description"].get<std::string>();
      response.uploadDate = j["uploadDate"].get<std::string>();
      response.uploader = j["uploader"].get<std::string>();
      response.uploaderUrl = j["uploaderUrl"].get<std::string>();
      response.uploaderAvatar = j["uploaderAvatar"].get<std::string>();
      response.thumbnailUrl = j["thumbnailUrl"].get<std::string>();
      response.hls = j["hls"].get<std::string>();
      if (j["dash"] != nullptr)
      {
        response.dash = new std::string(j["dash"].get<std::string>());
      }

      if (j["lbryId"] != nullptr)
      {
        response.lbryId = new std::string(j["lbryId"].get<std::string>());
      }

      response.category = j["category"].get<std::string>();
      response.license = j["license"].get<std::string>();
      response.visibility = j["visibility"].get<std::string>();

      // Tags
      std::vector<std::string> tags{};
      const auto _tags = j["tags"].get<json::array_t>();
      for (const auto &tag : _tags)
      {
        tags.push_back(tag);
      }
      response.tags = tags;

      // Metainfo
      std::vector<std::string> meta{};
      const auto _meta = j["metaInfo"].get<json::array_t>();
      for (const auto &m : _meta)
      {
        meta.push_back(m);
      }
      response.metaInfo = meta;

      response.uploaderVerified = j["uploaderVerified"].get<bool>();
      response.duration = j["duration"].get<uint>();
      response.duration = j["duration"].get<uint>();
      response.views = j["views"].get<uint>();
      response.likes = j["likes"].get<uint>();
      response.dislikes = j["dislikes"].get<uint>();
      response.uploaderSubscriberCount = j["uploaderSubscriberCount"].get<uint>();
    }

  public:
    struct Response
    {
      std::string title;
      std::string description;
      std::string uploadDate;
      std::string uploader;
      std::string uploaderUrl;
      std::string uploaderAvatar;
      std::string thumbnailUrl;
      std::string hls;
      std::string *dash = nullptr;
      std::string *lbryId = nullptr;
      std::string category;
      std::string license;
      std::string visibility;
      std::vector<std::string> tags;
      std::vector<std::string> metaInfo;
      std::string uploaderVerified;
      uint duration;
      uint views;
      uint likes;
      uint dislikes;
      uint uploaderSubscriberCount;
      bool livestream;
      std::string proxyUrl;
      std::vector<std::string> chapters;
      std::vector<PreviewFrame> previewFrames;
    } response;

    struct Stream
    {
      std::string url;
      std::string format;
      std::string quality;
      std::string mimeType;
      std::string codec;
      uint *audioTrackId = nullptr;
      std::string *audioTrackName = nullptr;
      std::string *audioTrackType = nullptr;
      std::string *audioTrackLocale = nullptr;
      bool videoOnly;
      uint itag;
      uint bitrate;
      uint initStart;
      uint initEnd;
      uint indexStart;
      uint indexEnd;
      uint width;
      uint height;
      uint fps;
      int contentLength;
    };

    struct RelatedStream
    {
      std::string url;
      std::string type;
      std::string title;
      std::string thumbnail;
      std::string uploaderName;
      std::string uploaderUrl;
      std::string uploaderAvatar;
      std::string uploadedDate;
      std::string *shortDescription = nullptr;
      uint duration;
      uint views;
      uint uploaded;
      bool uploaderVerified;
      bool isShort;
    };

    struct Subtitle
    {
      std::string url;
      std::string mimeType;
      std::string name;
      std::string code;
      bool autoGenerated;
    };

    struct PreviewFrame
    {
      std::vector<std::string> url;
      uint frameWidth;
      uint frameHeight;
      uint totalCount;
      uint durationPerFrame;
      uint framesPerPageX;
      uint framesPerPageY;
    };

  private:
    using json = nlohmann::json;
    Error error;
  };
} // namespace piped
